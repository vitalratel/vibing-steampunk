package adt

import (
	"context"
	"fmt"
	"strings"
	"time"
)

// --- Execute ABAP Code via Unit Test ---

// ExecuteABAPResult represents the result of executing ABAP code via unit test.
type ExecuteABAPResult struct {
	Success       bool            `json:"success"`
	ProgramName   string          `json:"programName"`
	Output        []string        `json:"output"`              // Values returned via assertion messages
	RawAlerts     []UnitTestAlert `json:"rawAlerts,omitempty"` // Full alert details for debugging
	ExecutionTime float64         `json:"executionTime"`       // Execution time in seconds
	Message       string          `json:"message,omitempty"`
	CleanedUp     bool            `json:"cleanedUp"`
}

// ExecuteABAPOptions configures ExecuteABAP behavior.
type ExecuteABAPOptions struct {
	// RiskLevel controls what operations the code can perform:
	// - "harmless" (default): No DB writes, no external calls
	// - "dangerous": Can write to DB, call external services
	// - "critical": Full system access (use with caution!)
	RiskLevel string

	// ReturnVariable is the name of the variable to return via assertion.
	// The code should set this variable, and its value will be returned.
	// If empty, uses "lv_result" by default.
	ReturnVariable string

	// KeepProgram prevents cleanup of the temp program (for debugging).
	KeepProgram bool

	// ProgramPrefix is the prefix for the temp program name.
	// Default is "ZTEMP_EXEC_".
	ProgramPrefix string
}

// ExecuteABAP executes arbitrary ABAP code via a temporary unit test wrapper.
//
// This is a powerful tool that allows executing any ABAP code on the SAP system.
// The code is wrapped in a test class and executed via RunUnitTests.
// Return values are extracted from assertion messages.
//
// Workflow:
// 1. Generate unique temp program name
// 2. Create program with test class wrapper
// 3. Inject user code into test method
// 4. Activate program
// 5. Run unit tests
// 6. Parse assertion messages for return values
// 7. Delete temp program (unless KeepProgram=true)
//
// Example:
//
//	result, err := client.ExecuteABAP(ctx, `
//	  DATA(lv_msg) = |Hello from SAP at { sy-datum } { sy-uzeit }|.
//	  DATA(lv_user) = sy-uname.
//	  lv_result = |{ lv_msg } by { lv_user }|.
//	`, nil)
//	// result.Output contains the assertion message with lv_result value
//
// Security: This is gated by OpWorkflow safety check.
func (c *Client) ExecuteABAP(ctx context.Context, code string, opts *ExecuteABAPOptions) (*ExecuteABAPResult, error) {
	// Safety check for workflow operations
	if err := c.checkSafety(OpWorkflow, "ExecuteABAP"); err != nil {
		return nil, err
	}

	if opts == nil {
		opts = &ExecuteABAPOptions{}
	}
	if opts.RiskLevel == "" {
		opts.RiskLevel = "harmless"
	}
	if opts.ReturnVariable == "" {
		opts.ReturnVariable = "lv_result"
	}
	if opts.ProgramPrefix == "" {
		opts.ProgramPrefix = "ZTEMP_EXEC_"
	}

	result := &ExecuteABAPResult{
		Output: []string{},
	}

	// Generate unique program name using timestamp
	timestamp := fmt.Sprintf("%d", time.Now().UnixNano()/1000000)                     // milliseconds
	programName := strings.ToUpper(opts.ProgramPrefix + timestamp[len(timestamp)-8:]) // Last 8 digits
	result.ProgramName = programName
	objectURL := fmt.Sprintf("/sap/bc/adt/programs/programs/%s", programName)

	// Build the test class wrapper source
	riskLevelABAP := "RISK LEVEL HARMLESS"
	switch strings.ToLower(opts.RiskLevel) {
	case "dangerous":
		riskLevelABAP = "RISK LEVEL DANGEROUS"
	case "critical":
		riskLevelABAP = "RISK LEVEL CRITICAL"
	}

	source := fmt.Sprintf(`REPORT %s.

*&---------------------------------------------------------------------*
*& Auto-generated program for code execution via unit test
*& Generated by vsp ExecuteABAP workflow
*&---------------------------------------------------------------------*

CLASS ltc_executor DEFINITION FOR TESTING %s DURATION SHORT.
  PUBLIC SECTION.
    METHODS execute_payload FOR TESTING.
ENDCLASS.

CLASS ltc_executor IMPLEMENTATION.
  METHOD execute_payload.
    DATA %s TYPE string.

    " === USER CODE START ===
%s
    " === USER CODE END ===

    " Return result via assertion message
    cl_abap_unit_assert=>fail( msg = |EXEC_RESULT:{ %s }| ).
  ENDMETHOD.
ENDCLASS.
`, programName, riskLevelABAP, opts.ReturnVariable, code, opts.ReturnVariable)

	// Step 1: Create the temp program
	err := c.CreateObject(ctx, CreateObjectOptions{
		ObjectType:  ObjectTypeProgram,
		Name:        programName,
		Description: "Temp program for ExecuteABAP",
		PackageName: "$TMP",
	})
	if err != nil {
		result.Message = fmt.Sprintf("Failed to create temp program: %v", err)
		return result, nil
	}

	// Ensure cleanup on any error (unless KeepProgram is set)
	defer func() {
		if !opts.KeepProgram {
			// Try to delete the program
			lock, lockErr := c.LockObject(ctx, objectURL, "MODIFY")
			if lockErr == nil {
				_ = c.DeleteObject(ctx, objectURL, lock.LockHandle, "")
				result.CleanedUp = true
			}
		}
	}()

	// Step 2: Lock and update source
	lock, err := c.LockObject(ctx, objectURL, "MODIFY")
	if err != nil {
		result.Message = fmt.Sprintf("Failed to lock temp program: %v", err)
		return result, nil
	}

	sourceURL := objectURL + "/source/main"
	err = c.UpdateSource(ctx, sourceURL, source, lock.LockHandle, "")
	if err != nil {
		_ = c.UnlockObject(ctx, objectURL, lock.LockHandle)
		result.Message = fmt.Sprintf("Failed to update source: %v", err)
		return result, nil
	}

	// Step 3: Unlock
	err = c.UnlockObject(ctx, objectURL, lock.LockHandle)
	if err != nil {
		result.Message = fmt.Sprintf("Failed to unlock: %v", err)
		return result, nil
	}

	// Step 4: Activate
	_, err = c.Activate(ctx, objectURL, programName)
	if err != nil {
		result.Message = fmt.Sprintf("Failed to activate: %v", err)
		return result, nil
	}

	// Step 5: Run unit tests
	flags := UnitTestRunFlags{
		Harmless:  true,
		Dangerous: strings.ToLower(opts.RiskLevel) == "dangerous" || strings.ToLower(opts.RiskLevel) == "critical",
		Critical:  strings.ToLower(opts.RiskLevel) == "critical",
		Short:     true,
		Medium:    true,
		Long:      false,
	}

	testResult, err := c.RunUnitTests(ctx, objectURL, &flags)
	if err != nil {
		result.Message = fmt.Sprintf("Failed to run unit tests: %v", err)
		return result, nil
	}

	// Step 6: Parse results - extract assertion messages
	for _, class := range testResult.Classes {
		for _, method := range class.TestMethods {
			result.ExecutionTime += method.ExecutionTime
			for _, alert := range method.Alerts {
				result.RawAlerts = append(result.RawAlerts, alert)

				// Look for our EXEC_RESULT marker in the alert title
				if strings.HasPrefix(alert.Title, "EXEC_RESULT:") {
					output := strings.TrimPrefix(alert.Title, "EXEC_RESULT:")
					result.Output = append(result.Output, output)
				}

				// Also check details for additional output
				for _, detail := range alert.Details {
					if strings.HasPrefix(detail, "EXEC_RESULT:") {
						output := strings.TrimPrefix(detail, "EXEC_RESULT:")
						result.Output = append(result.Output, output)
					}
				}
			}
		}
	}

	result.Success = true
	if len(result.Output) > 0 {
		result.Message = fmt.Sprintf("Executed successfully, %d output(s) returned", len(result.Output))
	} else {
		result.Message = "Executed successfully (no output captured)"
	}

	return result, nil
}

// ExecuteABAPMultiple executes ABAP code and returns multiple results via chained assertions.
// Each call to RETURN_VALUE( ) in the code adds a value to the output.
//
// Example:
//
//	result, err := client.ExecuteABAPMultiple(ctx, `
//	  SELECT * FROM t000 INTO TABLE @DATA(lt_clients) UP TO 5 ROWS.
//	  LOOP AT lt_clients INTO DATA(ls_client).
//	    RETURN_VALUE( |Client { ls_client-mandt }: { ls_client-mtext }| ).
//	  ENDLOOP.
//	`, nil)
//	// result.Output contains one entry per client
func (c *Client) ExecuteABAPMultiple(ctx context.Context, code string, opts *ExecuteABAPOptions) (*ExecuteABAPResult, error) {
	// Wrap the code with a macro that chains assertions
	wrappedCode := `
    DATA lt_exec_results TYPE string_table.

    DEFINE RETURN_VALUE.
      APPEND &1 TO lt_exec_results.
    END-OF-DEFINITION.

    ` + code + `

    " Output all collected results
    DATA lv_idx TYPE i.
    LOOP AT lt_exec_results INTO DATA(lv_exec_result).
      lv_idx = lv_idx + 1.
      cl_abap_unit_assert=>fail( msg = |EXEC_RESULT:{ lv_exec_result }| ).
    ENDLOOP.

    " Mark completion
    lv_result = |Completed with { lines( lt_exec_results ) } results|.
`

	return c.ExecuteABAP(ctx, wrappedCode, opts)
}
